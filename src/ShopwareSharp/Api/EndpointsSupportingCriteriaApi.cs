// <auto-generated>
/*
 * Shopware Store API
 *
 * This endpoint reference contains an overview of all endpoints comprising the Shopware Store API
 *
 * The version of the OpenAPI document: 6.4.9999999.9999999-dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using ShopwareSharp.Client;
using ShopwareSharp.Model;

namespace ShopwareSharp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEndpointsSupportingCriteriaApi : IApi
    {
        /// <summary>
        /// Fetch addresses of a customer
        /// </summary>
        /// <remarks>
        /// Lists all addresses of the current customer and allows filtering them based on a criteria.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;List&lt;CustomerAddress&gt;?&gt;&gt;</returns>
        Task<ApiResponse<List<CustomerAddress>?>> ListAddressWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch addresses of a customer
        /// </summary>
        /// <remarks>
        /// Lists all addresses of the current customer and allows filtering them based on a criteria.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;List&lt;CustomerAddress&gt;&gt;</returns>
        Task<List<CustomerAddress>?> ListAddressAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch addresses of a customer
        /// </summary>
        /// <remarks>
        /// Lists all addresses of the current customer and allows filtering them based on a criteria.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;List&lt;CustomerAddress&gt;?&gt;</returns>
        Task<List<CustomerAddress>?> ListAddressOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a single category
        /// </summary>
        /// <remarks>
        /// This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;Category?&gt;&gt;</returns>
        Task<ApiResponse<Category?>> ReadCategoryWithHttpInfoAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a single category
        /// </summary>
        /// <remarks>
        /// This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;Category&gt;</returns>
        Task<Category?> ReadCategoryAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a single category
        /// </summary>
        /// <remarks>
        /// This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </remarks>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;Category?&gt;</returns>
        Task<Category?> ReadCategoryOrDefaultAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a list of categories
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for categories.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadCategoryList200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadCategoryList200Response?>> ReadCategoryListWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of categories
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for categories.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCategoryList200Response&gt;</returns>
        Task<ReadCategoryList200Response?> ReadCategoryListAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of categories
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for categories.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCategoryList200Response?&gt;</returns>
        Task<ReadCategoryList200Response?> ReadCategoryListOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch countries
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for countries
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadCountry200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadCountry200Response?>> ReadCountryWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch countries
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for countries
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCountry200Response&gt;</returns>
        Task<ReadCountry200Response?> ReadCountryAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch countries
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for countries
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCountry200Response?&gt;</returns>
        Task<ReadCountry200Response?> ReadCountryOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch currencies
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for currencies.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadCurrency200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadCurrency200Response?>> ReadCurrencyWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch currencies
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for currencies.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCurrency200Response&gt;</returns>
        Task<ReadCurrency200Response?> ReadCurrencyAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch currencies
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for currencies.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCurrency200Response?&gt;</returns>
        Task<ReadCurrency200Response?> ReadCurrencyOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Get information about current customer
        /// </summary>
        /// <remarks>
        /// Returns information about the current customer.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;Customer?&gt;&gt;</returns>
        Task<ApiResponse<Customer?>> ReadCustomerWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Get information about current customer
        /// </summary>
        /// <remarks>
        /// Returns information about the current customer.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;Customer&gt;</returns>
        Task<Customer?> ReadCustomerAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Get information about current customer
        /// </summary>
        /// <remarks>
        /// Returns information about the current customer.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;Customer?&gt;</returns>
        Task<Customer?> ReadCustomerOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a wishlist
        /// </summary>
        /// <remarks>
        /// Fetch a customer&#39;s wishlist. Products on the wishlist can be filtered using a criteria object.  **Important constraints**  * Anonymous (not logged-in) customers can not have wishlists. * The wishlist feature has to be activated.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;WishlistLoadRouteResponse?&gt;&gt;</returns>
        Task<ApiResponse<WishlistLoadRouteResponse?>> ReadCustomerWishlistWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a wishlist
        /// </summary>
        /// <remarks>
        /// Fetch a customer&#39;s wishlist. Products on the wishlist can be filtered using a criteria object.  **Important constraints**  * Anonymous (not logged-in) customers can not have wishlists. * The wishlist feature has to be activated.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;WishlistLoadRouteResponse&gt;</returns>
        Task<WishlistLoadRouteResponse?> ReadCustomerWishlistAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a wishlist
        /// </summary>
        /// <remarks>
        /// Fetch a customer&#39;s wishlist. Products on the wishlist can be filtered using a criteria object.  **Important constraints**  * Anonymous (not logged-in) customers can not have wishlists. * The wishlist feature has to be activated.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;WishlistLoadRouteResponse?&gt;</returns>
        Task<WishlistLoadRouteResponse?> ReadCustomerWishlistOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a landing page with the resolved CMS page
        /// </summary>
        /// <remarks>
        /// Loads a landing page by its identifier and resolves the CMS page.  **Important notice**  The criteria passed with this route also affects the listing, if there is one within the cms page.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="landingPageId">Identifier of the landing page.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readLandingPageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;LandingPage?&gt;&gt;</returns>
        Task<ApiResponse<LandingPage?>> ReadLandingPageWithHttpInfoAsync(string landingPageId, string contentType, string accept, ReadLandingPageRequest? readLandingPageRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a landing page with the resolved CMS page
        /// </summary>
        /// <remarks>
        /// Loads a landing page by its identifier and resolves the CMS page.  **Important notice**  The criteria passed with this route also affects the listing, if there is one within the cms page.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="landingPageId">Identifier of the landing page.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readLandingPageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;LandingPage&gt;</returns>
        Task<LandingPage?> ReadLandingPageAsync(string landingPageId, string contentType, string accept, ReadLandingPageRequest? readLandingPageRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a landing page with the resolved CMS page
        /// </summary>
        /// <remarks>
        /// Loads a landing page by its identifier and resolves the CMS page.  **Important notice**  The criteria passed with this route also affects the listing, if there is one within the cms page.
        /// </remarks>
        /// <param name="landingPageId">Identifier of the landing page.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readLandingPageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;LandingPage?&gt;</returns>
        Task<LandingPage?> ReadLandingPageOrDefaultAsync(string landingPageId, string contentType, string accept, ReadLandingPageRequest? readLandingPageRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch languages
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for languages.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadLanguages200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadLanguages200Response?>> ReadLanguagesWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch languages
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for languages.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadLanguages200Response&gt;</returns>
        Task<ReadLanguages200Response?> ReadLanguagesAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch languages
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for languages.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadLanguages200Response?&gt;</returns>
        Task<ReadLanguages200Response?> ReadLanguagesOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a navigation menu
        /// </summary>
        /// <remarks>
        /// This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;List&lt;Category&gt;?&gt;&gt;</returns>
        Task<ApiResponse<List<Category>?>> ReadNavigationWithHttpInfoAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a navigation menu
        /// </summary>
        /// <remarks>
        /// This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;List&lt;Category&gt;&gt;</returns>
        Task<List<Category>?> ReadNavigationAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a navigation menu
        /// </summary>
        /// <remarks>
        /// This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </remarks>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;List&lt;Category&gt;?&gt;</returns>
        Task<List<Category>?> ReadNavigationOrDefaultAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a list of orders
        /// </summary>
        /// <remarks>
        /// List orders of a customer.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readOrderRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;OrderRouteResponse?&gt;&gt;</returns>
        Task<ApiResponse<OrderRouteResponse?>> ReadOrderWithHttpInfoAsync(ReadOrderRequest readOrderRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of orders
        /// </summary>
        /// <remarks>
        /// List orders of a customer.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readOrderRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;OrderRouteResponse&gt;</returns>
        Task<OrderRouteResponse?> ReadOrderAsync(ReadOrderRequest readOrderRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of orders
        /// </summary>
        /// <remarks>
        /// List orders of a customer.
        /// </remarks>
        /// <param name="readOrderRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;OrderRouteResponse?&gt;</returns>
        Task<OrderRouteResponse?> ReadOrderOrDefaultAsync(ReadOrderRequest readOrderRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Loads all available payment methods
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readPaymentMethodRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadPaymentMethod200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadPaymentMethod200Response?>> ReadPaymentMethodWithHttpInfoAsync(ReadPaymentMethodRequest readPaymentMethodRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Loads all available payment methods
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readPaymentMethodRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadPaymentMethod200Response&gt;</returns>
        Task<ReadPaymentMethod200Response?> ReadPaymentMethodAsync(ReadPaymentMethodRequest readPaymentMethodRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Loads all available payment methods
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="readPaymentMethodRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadPaymentMethod200Response?&gt;</returns>
        Task<ReadPaymentMethod200Response?> ReadPaymentMethodOrDefaultAsync(ReadPaymentMethodRequest readPaymentMethodRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a list of products
        /// </summary>
        /// <remarks>
        /// List products that match the given criteria. For performance ressons a limit should always be set.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadProduct200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadProduct200Response?>> ReadProductWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of products
        /// </summary>
        /// <remarks>
        /// List products that match the given criteria. For performance ressons a limit should always be set.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadProduct200Response&gt;</returns>
        Task<ReadProduct200Response?> ReadProductAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of products
        /// </summary>
        /// <remarks>
        /// List products that match the given criteria. For performance ressons a limit should always be set.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadProduct200Response?&gt;</returns>
        Task<ReadProduct200Response?> ReadProductOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch product reviews
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for product reviews.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Identifier of the product.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadProductReviews200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadProductReviews200Response?>> ReadProductReviewsWithHttpInfoAsync(string productId, string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch product reviews
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for product reviews.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Identifier of the product.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadProductReviews200Response&gt;</returns>
        Task<ReadProductReviews200Response?> ReadProductReviewsAsync(string productId, string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch product reviews
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for product reviews.
        /// </remarks>
        /// <param name="productId">Identifier of the product.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadProductReviews200Response?&gt;</returns>
        Task<ReadProductReviews200Response?> ReadProductReviewsOrDefaultAsync(string productId, string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch salutations
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for salutations.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadSalutation200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadSalutation200Response?>> ReadSalutationWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch salutations
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for salutations.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadSalutation200Response&gt;</returns>
        Task<ReadSalutation200Response?> ReadSalutationAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch salutations
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for salutations.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadSalutation200Response?&gt;</returns>
        Task<ReadSalutation200Response?> ReadSalutationOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch SEO routes
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for seo urls.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadSeoUrl200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadSeoUrl200Response?>> ReadSeoUrlWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch SEO routes
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for seo urls.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadSeoUrl200Response&gt;</returns>
        Task<ReadSeoUrl200Response?> ReadSeoUrlAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch SEO routes
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for seo urls.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadSeoUrl200Response?&gt;</returns>
        Task<ReadSeoUrl200Response?> ReadSeoUrlOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch shipping methods
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for shipping methods.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="onlyAvailable">List only available shipping methods. This filters shipping methods methods which can not be used in the actual context because of their availability rule. (optional)</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadShippingMethod200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadShippingMethod200Response?>> ReadShippingMethodWithHttpInfoAsync(string contentType, string accept, bool? onlyAvailable = null, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch shipping methods
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for shipping methods.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="onlyAvailable">List only available shipping methods. This filters shipping methods methods which can not be used in the actual context because of their availability rule. (optional)</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadShippingMethod200Response&gt;</returns>
        Task<ReadShippingMethod200Response?> ReadShippingMethodAsync(string contentType, string accept, bool? onlyAvailable = null, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch shipping methods
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for shipping methods.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="onlyAvailable">List only available shipping methods. This filters shipping methods methods which can not be used in the actual context because of their availability rule. (optional)</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadShippingMethod200Response?&gt;</returns>
        Task<ReadShippingMethod200Response?> ReadShippingMethodOrDefaultAsync(string contentType, string accept, bool? onlyAvailable = null, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

            }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class EndpointsSupportingCriteriaApi : IEndpointsSupportingCriteriaApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// An event to track the health of the server. 
        /// If you store these event args, be sure to purge old event args to prevent a memory leak.
        /// </summary>
        public event ClientUtils.EventHandler<ApiResponseEventArgs>? ApiResponded;

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<EndpointsSupportingCriteriaApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="EndpointsSupportingCriteriaApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EndpointsSupportingCriteriaApi(ILogger<EndpointsSupportingCriteriaApi> logger, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, 
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            Logger = logger;
            HttpClient = httpClient;
            ApiKeyProvider = apiKeyProvider;
        }

        /// <summary>
        /// Fetch addresses of a customer Lists all addresses of the current customer and allows filtering them based on a criteria.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="List&lt;CustomerAddress&gt;"/>&gt;</returns>
        public async Task<List<CustomerAddress>?> ListAddressAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<List<CustomerAddress>?> result = await ListAddressWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch addresses of a customer Lists all addresses of the current customer and allows filtering them based on a criteria.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="List&lt;CustomerAddress&gt;"/>&gt;</returns>
        public async Task<List<CustomerAddress>?> ListAddressOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<List<CustomerAddress>?>? result = null;
            try 
            {
                result = await ListAddressWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch addresses of a customer Lists all addresses of the current customer and allows filtering them based on a criteria.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="List&lt;CustomerAddress&gt;"/></returns>
        public async Task<ApiResponse<List<CustomerAddress>?>> ListAddressWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/account/list-address";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-context-token");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/account/list-address"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<List<CustomerAddress>?> apiResponse = new ApiResponse<List<CustomerAddress>?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<List<CustomerAddress>>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a single category This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="Category"/>&gt;</returns>
        public async Task<Category?> ReadCategoryAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<Category?> result = await ReadCategoryWithHttpInfoAsync(categoryId, contentType, accept, slots, readCategoryRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a single category This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="Category"/>&gt;</returns>
        public async Task<Category?> ReadCategoryOrDefaultAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<Category?>? result = null;
            try 
            {
                result = await ReadCategoryWithHttpInfoAsync(categoryId, contentType, accept, slots, readCategoryRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a single category This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="Category"/></returns>
        public async Task<ApiResponse<Category?>> ReadCategoryWithHttpInfoAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (categoryId == null)
                    throw new ArgumentNullException(nameof(categoryId));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/category/{categoryId}";
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BcategoryId%7D", Uri.EscapeDataString(categoryId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    if (slots != null)
                        parseQueryString["slots"] = Uri.EscapeDataString(slots.ToString()!);

                    uriBuilder.Query = parseQueryString.ToString();

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCategoryRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCategoryRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/category/{categoryId}"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<Category?> apiResponse = new ApiResponse<Category?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<Category>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a list of categories Perform a filtered search for categories.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCategoryList200Response"/>&gt;</returns>
        public async Task<ReadCategoryList200Response?> ReadCategoryListAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCategoryList200Response?> result = await ReadCategoryListWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a list of categories Perform a filtered search for categories.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCategoryList200Response"/>&gt;</returns>
        public async Task<ReadCategoryList200Response?> ReadCategoryListOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCategoryList200Response?>? result = null;
            try 
            {
                result = await ReadCategoryListWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a list of categories Perform a filtered search for categories.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadCategoryList200Response"/></returns>
        public async Task<ApiResponse<ReadCategoryList200Response?>> ReadCategoryListWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/category";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/category"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadCategoryList200Response?> apiResponse = new ApiResponse<ReadCategoryList200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadCategoryList200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch countries Perform a filtered search for countries
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCountry200Response"/>&gt;</returns>
        public async Task<ReadCountry200Response?> ReadCountryAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCountry200Response?> result = await ReadCountryWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch countries Perform a filtered search for countries
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCountry200Response"/>&gt;</returns>
        public async Task<ReadCountry200Response?> ReadCountryOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCountry200Response?>? result = null;
            try 
            {
                result = await ReadCountryWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch countries Perform a filtered search for countries
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadCountry200Response"/></returns>
        public async Task<ApiResponse<ReadCountry200Response?>> ReadCountryWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/country";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/country"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadCountry200Response?> apiResponse = new ApiResponse<ReadCountry200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadCountry200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch currencies Perform a filtered search for currencies.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCurrency200Response"/>&gt;</returns>
        public async Task<ReadCurrency200Response?> ReadCurrencyAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCurrency200Response?> result = await ReadCurrencyWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch currencies Perform a filtered search for currencies.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCurrency200Response"/>&gt;</returns>
        public async Task<ReadCurrency200Response?> ReadCurrencyOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCurrency200Response?>? result = null;
            try 
            {
                result = await ReadCurrencyWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch currencies Perform a filtered search for currencies.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadCurrency200Response"/></returns>
        public async Task<ApiResponse<ReadCurrency200Response?>> ReadCurrencyWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/currency";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/currency"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadCurrency200Response?> apiResponse = new ApiResponse<ReadCurrency200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadCurrency200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Get information about current customer Returns information about the current customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="Customer"/>&gt;</returns>
        public async Task<Customer?> ReadCustomerAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<Customer?> result = await ReadCustomerWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Get information about current customer Returns information about the current customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="Customer"/>&gt;</returns>
        public async Task<Customer?> ReadCustomerOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<Customer?>? result = null;
            try 
            {
                result = await ReadCustomerWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Get information about current customer Returns information about the current customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="Customer"/></returns>
        public async Task<ApiResponse<Customer?>> ReadCustomerWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/account/customer";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-context-token");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/account/customer"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<Customer?> apiResponse = new ApiResponse<Customer?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<Customer>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a wishlist Fetch a customer&#39;s wishlist. Products on the wishlist can be filtered using a criteria object.  **Important constraints**  * Anonymous (not logged-in) customers can not have wishlists. * The wishlist feature has to be activated.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="WishlistLoadRouteResponse"/>&gt;</returns>
        public async Task<WishlistLoadRouteResponse?> ReadCustomerWishlistAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<WishlistLoadRouteResponse?> result = await ReadCustomerWishlistWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a wishlist Fetch a customer&#39;s wishlist. Products on the wishlist can be filtered using a criteria object.  **Important constraints**  * Anonymous (not logged-in) customers can not have wishlists. * The wishlist feature has to be activated.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="WishlistLoadRouteResponse"/>&gt;</returns>
        public async Task<WishlistLoadRouteResponse?> ReadCustomerWishlistOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<WishlistLoadRouteResponse?>? result = null;
            try 
            {
                result = await ReadCustomerWishlistWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a wishlist Fetch a customer&#39;s wishlist. Products on the wishlist can be filtered using a criteria object.  **Important constraints**  * Anonymous (not logged-in) customers can not have wishlists. * The wishlist feature has to be activated.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="WishlistLoadRouteResponse"/></returns>
        public async Task<ApiResponse<WishlistLoadRouteResponse?>> ReadCustomerWishlistWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/customer/wishlist";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-context-token");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/customer/wishlist"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<WishlistLoadRouteResponse?> apiResponse = new ApiResponse<WishlistLoadRouteResponse?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<WishlistLoadRouteResponse>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a landing page with the resolved CMS page Loads a landing page by its identifier and resolves the CMS page.  **Important notice**  The criteria passed with this route also affects the listing, if there is one within the cms page.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="landingPageId">Identifier of the landing page.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readLandingPageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="LandingPage"/>&gt;</returns>
        public async Task<LandingPage?> ReadLandingPageAsync(string landingPageId, string contentType, string accept, ReadLandingPageRequest? readLandingPageRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<LandingPage?> result = await ReadLandingPageWithHttpInfoAsync(landingPageId, contentType, accept, readLandingPageRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a landing page with the resolved CMS page Loads a landing page by its identifier and resolves the CMS page.  **Important notice**  The criteria passed with this route also affects the listing, if there is one within the cms page.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="landingPageId">Identifier of the landing page.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readLandingPageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="LandingPage"/>&gt;</returns>
        public async Task<LandingPage?> ReadLandingPageOrDefaultAsync(string landingPageId, string contentType, string accept, ReadLandingPageRequest? readLandingPageRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<LandingPage?>? result = null;
            try 
            {
                result = await ReadLandingPageWithHttpInfoAsync(landingPageId, contentType, accept, readLandingPageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a landing page with the resolved CMS page Loads a landing page by its identifier and resolves the CMS page.  **Important notice**  The criteria passed with this route also affects the listing, if there is one within the cms page.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="landingPageId">Identifier of the landing page.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readLandingPageRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="LandingPage"/></returns>
        public async Task<ApiResponse<LandingPage?>> ReadLandingPageWithHttpInfoAsync(string landingPageId, string contentType, string accept, ReadLandingPageRequest? readLandingPageRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (landingPageId == null)
                    throw new ArgumentNullException(nameof(landingPageId));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/landing-page/{landingPageId}";
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BlandingPageId%7D", Uri.EscapeDataString(landingPageId.ToString()));

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readLandingPageRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readLandingPageRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json", 
                        "application/vnd.api+json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/landing-page/{landingPageId}"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<LandingPage?> apiResponse = new ApiResponse<LandingPage?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<LandingPage>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch languages Perform a filtered search for languages.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadLanguages200Response"/>&gt;</returns>
        public async Task<ReadLanguages200Response?> ReadLanguagesAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadLanguages200Response?> result = await ReadLanguagesWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch languages Perform a filtered search for languages.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadLanguages200Response"/>&gt;</returns>
        public async Task<ReadLanguages200Response?> ReadLanguagesOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadLanguages200Response?>? result = null;
            try 
            {
                result = await ReadLanguagesWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch languages Perform a filtered search for languages.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadLanguages200Response"/></returns>
        public async Task<ApiResponse<ReadLanguages200Response?>> ReadLanguagesWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/language";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/language"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadLanguages200Response?> apiResponse = new ApiResponse<ReadLanguages200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadLanguages200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a navigation menu This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="List&lt;Category&gt;"/>&gt;</returns>
        public async Task<List<Category>?> ReadNavigationAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<List<Category>?> result = await ReadNavigationWithHttpInfoAsync(requestActiveId, requestRootId, readNavigationRequest, contentType, accept, swIncludeSeoUrls, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a navigation menu This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="List&lt;Category&gt;"/>&gt;</returns>
        public async Task<List<Category>?> ReadNavigationOrDefaultAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<List<Category>?>? result = null;
            try 
            {
                result = await ReadNavigationWithHttpInfoAsync(requestActiveId, requestRootId, readNavigationRequest, contentType, accept, swIncludeSeoUrls, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a navigation menu This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="List&lt;Category&gt;"/></returns>
        public async Task<ApiResponse<List<Category>?>> ReadNavigationWithHttpInfoAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (requestActiveId == null)
                    throw new ArgumentNullException(nameof(requestActiveId));

                if (requestRootId == null)
                    throw new ArgumentNullException(nameof(requestRootId));

                if (readNavigationRequest == null)
                    throw new ArgumentNullException(nameof(readNavigationRequest));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/navigation/{requestActiveId}/{requestRootId}";
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BrequestActiveId%7D", Uri.EscapeDataString(requestActiveId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BrequestRootId%7D", Uri.EscapeDataString(requestRootId.ToString()));

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    if (swIncludeSeoUrls != null)
                        request.Headers.Add("sw-include-seo-urls", ClientUtils.ParameterToString(swIncludeSeoUrls));

                    request.Content = (readNavigationRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readNavigationRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/navigation/{requestActiveId}/{requestRootId}"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<List<Category>?> apiResponse = new ApiResponse<List<Category>?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<List<Category>>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a list of orders List orders of a customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readOrderRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="OrderRouteResponse"/>&gt;</returns>
        public async Task<OrderRouteResponse?> ReadOrderAsync(ReadOrderRequest readOrderRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<OrderRouteResponse?> result = await ReadOrderWithHttpInfoAsync(readOrderRequest, contentType, accept, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a list of orders List orders of a customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readOrderRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="OrderRouteResponse"/>&gt;</returns>
        public async Task<OrderRouteResponse?> ReadOrderOrDefaultAsync(ReadOrderRequest readOrderRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<OrderRouteResponse?>? result = null;
            try 
            {
                result = await ReadOrderWithHttpInfoAsync(readOrderRequest, contentType, accept, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a list of orders List orders of a customer.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readOrderRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="OrderRouteResponse"/></returns>
        public async Task<ApiResponse<OrderRouteResponse?>> ReadOrderWithHttpInfoAsync(ReadOrderRequest readOrderRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (readOrderRequest == null)
                    throw new ArgumentNullException(nameof(readOrderRequest));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/order";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readOrderRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readOrderRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/order"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<OrderRouteResponse?> apiResponse = new ApiResponse<OrderRouteResponse?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<OrderRouteResponse>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Loads all available payment methods 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readPaymentMethodRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadPaymentMethod200Response"/>&gt;</returns>
        public async Task<ReadPaymentMethod200Response?> ReadPaymentMethodAsync(ReadPaymentMethodRequest readPaymentMethodRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadPaymentMethod200Response?> result = await ReadPaymentMethodWithHttpInfoAsync(readPaymentMethodRequest, contentType, accept, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Loads all available payment methods 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readPaymentMethodRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadPaymentMethod200Response"/>&gt;</returns>
        public async Task<ReadPaymentMethod200Response?> ReadPaymentMethodOrDefaultAsync(ReadPaymentMethodRequest readPaymentMethodRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadPaymentMethod200Response?>? result = null;
            try 
            {
                result = await ReadPaymentMethodWithHttpInfoAsync(readPaymentMethodRequest, contentType, accept, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Loads all available payment methods 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="readPaymentMethodRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadPaymentMethod200Response"/></returns>
        public async Task<ApiResponse<ReadPaymentMethod200Response?>> ReadPaymentMethodWithHttpInfoAsync(ReadPaymentMethodRequest readPaymentMethodRequest, string contentType, string accept, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (readPaymentMethodRequest == null)
                    throw new ArgumentNullException(nameof(readPaymentMethodRequest));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/payment-method";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readPaymentMethodRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readPaymentMethodRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/payment-method"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadPaymentMethod200Response?> apiResponse = new ApiResponse<ReadPaymentMethod200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadPaymentMethod200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a list of products List products that match the given criteria. For performance ressons a limit should always be set.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadProduct200Response"/>&gt;</returns>
        public async Task<ReadProduct200Response?> ReadProductAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadProduct200Response?> result = await ReadProductWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a list of products List products that match the given criteria. For performance ressons a limit should always be set.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadProduct200Response"/>&gt;</returns>
        public async Task<ReadProduct200Response?> ReadProductOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadProduct200Response?>? result = null;
            try 
            {
                result = await ReadProductWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a list of products List products that match the given criteria. For performance ressons a limit should always be set.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadProduct200Response"/></returns>
        public async Task<ApiResponse<ReadProduct200Response?>> ReadProductWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/product";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/product"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadProduct200Response?> apiResponse = new ApiResponse<ReadProduct200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadProduct200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch product reviews Perform a filtered search for product reviews.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Identifier of the product.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadProductReviews200Response"/>&gt;</returns>
        public async Task<ReadProductReviews200Response?> ReadProductReviewsAsync(string productId, string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadProductReviews200Response?> result = await ReadProductReviewsWithHttpInfoAsync(productId, contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch product reviews Perform a filtered search for product reviews.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Identifier of the product.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadProductReviews200Response"/>&gt;</returns>
        public async Task<ReadProductReviews200Response?> ReadProductReviewsOrDefaultAsync(string productId, string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadProductReviews200Response?>? result = null;
            try 
            {
                result = await ReadProductReviewsWithHttpInfoAsync(productId, contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch product reviews Perform a filtered search for product reviews.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="productId">Identifier of the product.</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadProductReviews200Response"/></returns>
        public async Task<ApiResponse<ReadProductReviews200Response?>> ReadProductReviewsWithHttpInfoAsync(string productId, string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (productId == null)
                    throw new ArgumentNullException(nameof(productId));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/product/{productId}/reviews";
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BproductId%7D", Uri.EscapeDataString(productId.ToString()));

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/product/{productId}/reviews"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadProductReviews200Response?> apiResponse = new ApiResponse<ReadProductReviews200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadProductReviews200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch salutations Perform a filtered search for salutations.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadSalutation200Response"/>&gt;</returns>
        public async Task<ReadSalutation200Response?> ReadSalutationAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadSalutation200Response?> result = await ReadSalutationWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch salutations Perform a filtered search for salutations.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadSalutation200Response"/>&gt;</returns>
        public async Task<ReadSalutation200Response?> ReadSalutationOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadSalutation200Response?>? result = null;
            try 
            {
                result = await ReadSalutationWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch salutations Perform a filtered search for salutations.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadSalutation200Response"/></returns>
        public async Task<ApiResponse<ReadSalutation200Response?>> ReadSalutationWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/salutation";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/salutation"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadSalutation200Response?> apiResponse = new ApiResponse<ReadSalutation200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadSalutation200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch SEO routes Perform a filtered search for seo urls.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadSeoUrl200Response"/>&gt;</returns>
        public async Task<ReadSeoUrl200Response?> ReadSeoUrlAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadSeoUrl200Response?> result = await ReadSeoUrlWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch SEO routes Perform a filtered search for seo urls.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadSeoUrl200Response"/>&gt;</returns>
        public async Task<ReadSeoUrl200Response?> ReadSeoUrlOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadSeoUrl200Response?>? result = null;
            try 
            {
                result = await ReadSeoUrlWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch SEO routes Perform a filtered search for seo urls.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadSeoUrl200Response"/></returns>
        public async Task<ApiResponse<ReadSeoUrl200Response?>> ReadSeoUrlWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/seo-url";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json", 
                        "application/vnd.api+json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/seo-url"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadSeoUrl200Response?> apiResponse = new ApiResponse<ReadSeoUrl200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadSeoUrl200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch shipping methods Perform a filtered search for shipping methods.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="onlyAvailable">List only available shipping methods. This filters shipping methods methods which can not be used in the actual context because of their availability rule. (optional)</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadShippingMethod200Response"/>&gt;</returns>
        public async Task<ReadShippingMethod200Response?> ReadShippingMethodAsync(string contentType, string accept, bool? onlyAvailable = null, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadShippingMethod200Response?> result = await ReadShippingMethodWithHttpInfoAsync(contentType, accept, onlyAvailable, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch shipping methods Perform a filtered search for shipping methods.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="onlyAvailable">List only available shipping methods. This filters shipping methods methods which can not be used in the actual context because of their availability rule. (optional)</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadShippingMethod200Response"/>&gt;</returns>
        public async Task<ReadShippingMethod200Response?> ReadShippingMethodOrDefaultAsync(string contentType, string accept, bool? onlyAvailable = null, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadShippingMethod200Response?>? result = null;
            try 
            {
                result = await ReadShippingMethodWithHttpInfoAsync(contentType, accept, onlyAvailable, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch shipping methods Perform a filtered search for shipping methods.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="onlyAvailable">List only available shipping methods. This filters shipping methods methods which can not be used in the actual context because of their availability rule. (optional)</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadShippingMethod200Response"/></returns>
        public async Task<ApiResponse<ReadShippingMethod200Response?>> ReadShippingMethodWithHttpInfoAsync(string contentType, string accept, bool? onlyAvailable = null, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/shipping-method";

                    System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    if (onlyAvailable != null)
                        parseQueryString["onlyAvailable"] = Uri.EscapeDataString(onlyAvailable.ToString()!);

                    uriBuilder.Query = parseQueryString.ToString();

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/shipping-method"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadShippingMethod200Response?> apiResponse = new ApiResponse<ReadShippingMethod200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadShippingMethod200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }    }
}
