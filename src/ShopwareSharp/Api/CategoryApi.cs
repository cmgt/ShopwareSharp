// <auto-generated>
/*
 * Shopware Store API
 *
 * This endpoint reference contains an overview of all endpoints comprising the Shopware Store API
 *
 * The version of the OpenAPI document: 6.4.9999999.9999999-dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using ShopwareSharp.Client;
using ShopwareSharp.Model;

namespace ShopwareSharp.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICategoryApi : IApi
    {
        /// <summary>
        /// Fetch a single category
        /// </summary>
        /// <remarks>
        /// This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;Category?&gt;&gt;</returns>
        Task<ApiResponse<Category?>> ReadCategoryWithHttpInfoAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a single category
        /// </summary>
        /// <remarks>
        /// This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;Category&gt;</returns>
        Task<Category?> ReadCategoryAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a single category
        /// </summary>
        /// <remarks>
        /// This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </remarks>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;Category?&gt;</returns>
        Task<Category?> ReadCategoryOrDefaultAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a list of categories
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for categories.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;ReadCategoryList200Response?&gt;&gt;</returns>
        Task<ApiResponse<ReadCategoryList200Response?>> ReadCategoryListWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of categories
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for categories.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCategoryList200Response&gt;</returns>
        Task<ReadCategoryList200Response?> ReadCategoryListAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a list of categories
        /// </summary>
        /// <remarks>
        /// Perform a filtered search for categories.
        /// </remarks>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;ReadCategoryList200Response?&gt;</returns>
        Task<ReadCategoryList200Response?> ReadCategoryListOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null);

        
        /// <summary>
        /// Fetch a navigation menu
        /// </summary>
        /// <remarks>
        /// This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;List&lt;Category&gt;?&gt;&gt;</returns>
        Task<ApiResponse<List<Category>?>> ReadNavigationWithHttpInfoAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a navigation menu
        /// </summary>
        /// <remarks>
        /// This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;List&lt;Category&gt;&gt;</returns>
        Task<List<Category>?> ReadNavigationAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null);

        /// <summary>
        /// Fetch a navigation menu
        /// </summary>
        /// <remarks>
        /// This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </remarks>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;List&lt;Category&gt;?&gt;</returns>
        Task<List<Category>?> ReadNavigationOrDefaultAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null);

            }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CategoryApi : ICategoryApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// An event to track the health of the server. 
        /// If you store these event args, be sure to purge old event args to prevent a memory leak.
        /// </summary>
        public event ClientUtils.EventHandler<ApiResponseEventArgs>? ApiResponded;

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<CategoryApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CategoryApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CategoryApi(ILogger<CategoryApi> logger, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, 
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            Logger = logger;
            HttpClient = httpClient;
            ApiKeyProvider = apiKeyProvider;
        }

        /// <summary>
        /// Fetch a single category This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="Category"/>&gt;</returns>
        public async Task<Category?> ReadCategoryAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<Category?> result = await ReadCategoryWithHttpInfoAsync(categoryId, contentType, accept, slots, readCategoryRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a single category This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="Category"/>&gt;</returns>
        public async Task<Category?> ReadCategoryOrDefaultAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<Category?>? result = null;
            try 
            {
                result = await ReadCategoryWithHttpInfoAsync(categoryId, contentType, accept, slots, readCategoryRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a single category This endpoint returns information about the category, as well as a fully resolved (hydrated with mapping values) CMS page, if one is assigned to the category. You can pass slots which should be resolved exclusively.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="categoryId">Identifier of the category to be fetched</param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="slots">Resolves only the given slot identifiers. The identifiers have to be seperated by a &#39;|&#39; character (optional)</param>
        /// <param name="readCategoryRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="Category"/></returns>
        public async Task<ApiResponse<Category?>> ReadCategoryWithHttpInfoAsync(string categoryId, string contentType, string accept, string? slots = null, ReadCategoryRequest? readCategoryRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (categoryId == null)
                    throw new ArgumentNullException(nameof(categoryId));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/category/{categoryId}";
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BcategoryId%7D", Uri.EscapeDataString(categoryId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);
                    if (slots != null)
                        parseQueryString["slots"] = Uri.EscapeDataString(slots.ToString()!);

                    uriBuilder.Query = parseQueryString.ToString();

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCategoryRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCategoryRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/category/{categoryId}"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<Category?> apiResponse = new ApiResponse<Category?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<Category>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a list of categories Perform a filtered search for categories.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCategoryList200Response"/>&gt;</returns>
        public async Task<ReadCategoryList200Response?> ReadCategoryListAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCategoryList200Response?> result = await ReadCategoryListWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a list of categories Perform a filtered search for categories.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ReadCategoryList200Response"/>&gt;</returns>
        public async Task<ReadCategoryList200Response?> ReadCategoryListOrDefaultAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<ReadCategoryList200Response?>? result = null;
            try 
            {
                result = await ReadCategoryListWithHttpInfoAsync(contentType, accept, readCustomerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a list of categories Perform a filtered search for categories.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="readCustomerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="ReadCategoryList200Response"/></returns>
        public async Task<ApiResponse<ReadCategoryList200Response?>> ReadCategoryListWithHttpInfoAsync(string contentType, string accept, ReadCustomerRequest? readCustomerRequest = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/category";

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    request.Content = (readCustomerRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readCustomerRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/category"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<ReadCategoryList200Response?> apiResponse = new ApiResponse<ReadCategoryList200Response?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<ReadCategoryList200Response>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }

        /// <summary>
        /// Fetch a navigation menu This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="List&lt;Category&gt;"/>&gt;</returns>
        public async Task<List<Category>?> ReadNavigationAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<List<Category>?> result = await ReadNavigationWithHttpInfoAsync(requestActiveId, requestRootId, readNavigationRequest, contentType, accept, swIncludeSeoUrls, cancellationToken).ConfigureAwait(false);

            if (result.Content == null)
                throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);

            return result.Content;
        }

        /// <summary>
        /// Fetch a navigation menu This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="List&lt;Category&gt;"/>&gt;</returns>
        public async Task<List<Category>?> ReadNavigationOrDefaultAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            ApiResponse<List<Category>?>? result = null;
            try 
            {
                result = await ReadNavigationWithHttpInfoAsync(requestActiveId, requestRootId, readNavigationRequest, contentType, accept, swIncludeSeoUrls, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }

        /// <summary>
        /// Fetch a navigation menu This endpoint returns categories that can be used as a page navigation. You can either return them as a tree or as a flat list. You can also control the depth of the tree.      Instead of passing uuids, you can also use one of the following aliases for the activeId and rootId parameters to get the respective navigations of your sales channel.       * main-navigation      * service-navigation      * footer-navigation
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestActiveId">Identifier of the active category in the navigation tree (if not used, just set to the same as rootId).</param>
        /// <param name="requestRootId">Identifier of the root category for your desired navigation tree. You can use it to fetch sub-trees of your navigation tree.</param>
        /// <param name="readNavigationRequest"></param>
        /// <param name="contentType">Content type of the request</param>
        /// <param name="accept">Accepted response content types</param>
        /// <param name="swIncludeSeoUrls">Instructs Shopware to try and resolve SEO URLs for the given navigation item (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="List&lt;Category&gt;"/></returns>
        public async Task<ApiResponse<List<Category>?>> ReadNavigationWithHttpInfoAsync(string requestActiveId, string requestRootId, ReadNavigationRequest readNavigationRequest, string contentType, string accept, bool? swIncludeSeoUrls = null, System.Threading.CancellationToken? cancellationToken = null)
        {
            try
            {
                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                if (requestActiveId == null)
                    throw new ArgumentNullException(nameof(requestActiveId));

                if (requestRootId == null)
                    throw new ArgumentNullException(nameof(requestRootId));

                if (readNavigationRequest == null)
                    throw new ArgumentNullException(nameof(readNavigationRequest));

                if (contentType == null)
                    throw new ArgumentNullException(nameof(contentType));

                if (accept == null)
                    throw new ArgumentNullException(nameof(accept));

                #pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'

                using (HttpRequestMessage request = new HttpRequestMessage())
                {
                    UriBuilder uriBuilder = new UriBuilder();
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Scheme = ClientUtils.SCHEME;
                    uriBuilder.Path = ClientUtils.CONTEXT_PATH + "/navigation/{requestActiveId}/{requestRootId}";
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BrequestActiveId%7D", Uri.EscapeDataString(requestActiveId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BrequestRootId%7D", Uri.EscapeDataString(requestRootId.ToString()));

                    request.Headers.Add("Content-Type", ClientUtils.ParameterToString(contentType));

                    request.Headers.Add("Accept", ClientUtils.ParameterToString(accept));

                    if (swIncludeSeoUrls != null)
                        request.Headers.Add("sw-include-seo-urls", ClientUtils.ParameterToString(swIncludeSeoUrls));

                    request.Content = (readNavigationRequest as object) is System.IO.Stream stream
                        ? request.Content = new StreamContent(stream)
                        : request.Content = new StringContent(JsonSerializer.Serialize(readNavigationRequest, _jsonSerializerOptions));

                    List<TokenBase> tokens = new List<TokenBase>();

                    ApiKeyToken apiKey = (ApiKeyToken) await ApiKeyProvider.GetAsync(cancellationToken).ConfigureAwait(false);

                    tokens.Add(apiKey);

                    apiKey.UseInHeader(request, "sw-access-key");

                    request.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json" 
                    };

                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null)
                        request.Content.Headers.Add("ContentType", contentType);

                    string[] accepts = new string[] { 
                        "application/json" 
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                    
                    request.Method = HttpMethod.Post;

                    using (HttpResponseMessage responseMessage = await HttpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false))
                    {
                        DateTime requestedAt = DateTime.UtcNow;

                        string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                        if (ApiResponded != null)
                        {
                            try
                            {
                                ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "/navigation/{requestActiveId}/{requestRootId}"));
                            }
                            catch(Exception e)
                            {
                                Logger.LogError(e, "An error occured while invoking ApiResponded.");
                            }
                        }

                        ApiResponse<List<Category>?> apiResponse = new ApiResponse<List<Category>?>(responseMessage, responseContent);

                        if (apiResponse.IsSuccessStatusCode)
                            apiResponse.Content = JsonSerializer.Deserialize<List<Category>>(apiResponse.RawContent, _jsonSerializerOptions);
                        else if (apiResponse.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase token in tokens)
                                token.BeginRateLimit();

                        return apiResponse;
                    }
                }
            }
            catch(Exception e)
            {
                Logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }    }
}
